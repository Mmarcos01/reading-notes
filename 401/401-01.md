[Home](../README.md)

## Pain vs Suffering

Taking on a full course of stacked learning Advanced Software Development in 6 months will clearly not be easy. Pain will be felt as you're constantly pushed outside your comfort zone. A daily routine and life balance may be more difficult to maintain during this very challenging time.  

However, momentary sacrifices like these are what lead to growth.  

> Pain in the service of growth is a good thing, as long as that pain is what’s necessary to achieve the growth that you’re aiming for.  

Don't confuse pain with suffering; which is pain without purpose and with no higher goal. Suffering is dependent on the story that we layer on top of our pain- Consider your perspective and why you are doing this for yourself, keeping in mind the good that comes at the end of the all the hard work.

> Find the common thread that makes the pain worthwhile, that puts the pain into perspective. You’re here because you chose to invest in a different life. A better life.

You don't have to experience the pain alone, build your resources and community.

## A Beginners Guide to Big O Notation 
[Resource](https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation)  

Big O notation in Computer Science describes the complexity or performance of an algorithm- it describes the worst-case scenario, and the execution time required or the space/memory used by an algorithm.  

Not having a grounding in Mathematics can hinder understanding of concepts that mention mathematical syntax. These are some examples in code that may aide in understanding Big O:  

### O(1)

Describes an algorithm that will always execute in the same time (or space) regardless of the size of the input data set.  

### O(N)

Describes an algorithm whose performance will grow linearly and in direct proportion to the size of the input data set.  

### O(N²) 

Represents an algorithm whose performance is directly proportional to the square of the size of the input data set.  

### O(2^N) 

Denotes an algorithm whose growth doubles with each addition to the input data set.  

### Logarithms O(log N)

Time goes up linearly while the n goes up exponentially. Ex: if it takes 1 second to compute 10 elements, it will take 2 seconds to compute 100, 3 seconds to compute 1000, ect.

[Home](../README.md)
